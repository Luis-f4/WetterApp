Beende folgende funktion:

    @CrossOrigin(origins = "http://localhost:3000")
    @PutMapping(path = "/updateEmployee/{licensingID}/{email}/{department}/{company}/{subscriptionPack}/{po}/{amount}")
    public @ResponseBody String editEmployeeNew(@PathVariable int licensingID, @PathVariable String email, @PathVariable String department, @PathVariable String company, @PathVariable String subscriptionPack, @PathVariable String po, @PathVariable int amount) {

        Licensing licensing = licensingRepo.findById(licensingID).orElse(null);

        EmployeeEntity employee = (licensing != null) ? licensing.getEmployee() : null;

        Optional<LicenseEntity> licenseOpt = licenseRepo.searchLicense(subscriptionPack, po, amount);

        if (employee != null) {
            employee.setDepartment(department);
            employee.setCompany(company);
            employee.setEmail(email);
            employeeRepo.save(employee);
            System.out.println("Employee with email " + email + " found and updated.");
        } else {
            System.out.println("Employee with email " + email + " not found.");
            return "Employee not found!";
        }
/*
        if (licensing != null) {
            licensing.setEmployee(employee);
            if (licenseOpt.isPresent()) {
                licensing.setLicense(licenseOpt.get());
                licensingRepo.updateLicense(licensingID, licenseOpt.get().getId());
            } else {
                System.out.println("License not found.");
                return "License not found!";
            }
        }*/


        return "Employee and Licensing updated successfully!";
    }


Sinn der funktion: änderungen von employee sollen gespeichert werden und die id der lizenz soll anhand von subscriptionPack, po und amount gefunden werden. wenn beides geschehen ist soll die id der license bei licensing geupdatet werden.
hier sind weitere klassen:

package com.vodafone.spring_swlzfw;

import jakarta.persistence.*;
import java.util.List;

@Entity
public class EmployeeEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;

    private String email;
    private String department;
    private String company;

    // n:m Beziehung zu LicenseEntity mit Licensing als Join-Tabelle
    @OneToMany(mappedBy = "employee", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Licensing> licenses;

    // Getter und Setter
    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getDepartment() {
        return department;
    }

    public void setDepartment(String department) {
        this.department = department;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }

    public List<Licensing> getLicenses() {
        return licenses;
    }

    public void setLicenses(List<Licensing> licenses) {
        this.licenses = licenses;
    }
}


package com.vodafone.spring_swlzfw;

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;

import java.util.List;
import java.util.Optional;

public interface EmployeeRepo extends CrudRepository<EmployeeEntity, Integer> {

    // Query zur Rückgabe von Mitarbeiterinformationen und den zugehörigen Lizenzinformationen über die Licensing-Tabelle
    @Query(value = "SELECT e.email, e.department, e.company, l.subscription_pack, l.expiration_date, l.purchase_order, l.purchase_order_originally " +
            "FROM employee_entity e " +
            "JOIN licensing lic ON e.id = lic.employee_id " +
            "JOIN license_entity l ON lic.license_id = l.id", nativeQuery = true)
    public List<Object> getAll();

    // Suchanfrage, um nach einem Begriff in verschiedenen Feldern zu suchen (über Licensing-Tabelle)
    @Query(value = "SELECT e.email, e.company, e.department, l.subscription_pack, l.expiration_date, l.purchase_order, l.purchase_order_originally " +
            "FROM employee_entity e " +
            "JOIN licensing lic ON e.id = lic.employee_id " +
            "JOIN license_entity l ON lic.license_id = l.id " +
            "WHERE e.email LIKE %:search% " +
            "OR e.department LIKE %:search% " +
            "OR e.company LIKE %:search% " +
            "OR l.purchase_order LIKE %:search% " +
            "OR l.purchase_order_originally LIKE %:search% " +
            "OR l.subscription_pack LIKE %:search% " +
            "OR l.expiration_date LIKE %:search%", nativeQuery = true)
    public List<Object> find(@Param("search") String search);

    @Query(value = "SELECT * FROM employee_entity Where email = :email AND department = :department AND company = :company", nativeQuery = true)
    public Optional<EmployeeEntity> searchEmployee(@Param("email") String email, @Param("department") String department, @Param("company") String company);

}

package com.vodafone.spring_swlzfw;

import jakarta.persistence.*;

import java.time.LocalDate;
import java.util.List;

@Entity
public class LicenseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;

    private String subscriptionPack;
    private LocalDate expirationDate;
    private int purchaseOrder;
    private int purchaseOrderOriginally;
    private int amount;
    private LocalDate startDate;

    // n:m Beziehung zu EmployeeEntity mit Licensing als Join-Tabelle
    @OneToMany(mappedBy = "license", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Licensing> employees;

    // Getter und Setter
    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getSubscriptionPack() {
        return subscriptionPack;
    }

    public void setSubscriptionPack(String subscriptionPack) {
        this.subscriptionPack = subscriptionPack;
    }

    public LocalDate getExpirationDate() {
        return expirationDate;
    }

    public void setExpirationDate(LocalDate expirationDate) {
        this.expirationDate = expirationDate;
    }

    public int getPurchaseOrder() {
        return purchaseOrder;
    }

    public void setPurchaseOrder(int purchaseOrder) {
        this.purchaseOrder = purchaseOrder;
    }

    public int getPurchaseOrderOriginally() {
        return purchaseOrderOriginally;
    }

    public void setPurchaseOrderOriginally(int purchaseOrderOriginally) {
        this.purchaseOrderOriginally = purchaseOrderOriginally;
    }

    public int getAmount() {
        return amount;
    }

    public void setAmount(int amount) {
        this.amount = amount;
    }

    public LocalDate getStartDate() {
        return startDate;
    }

    public void setStartDate(LocalDate startDate) {
        this.startDate = startDate;
    }

    public List<Licensing> getEmployees() {
        return employees;
    }

    public void setEmployees(List<Licensing> employees) {
        this.employees = employees;
    }
}


package com.vodafone.spring_swlzfw;

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;

import java.util.List;
import java.util.Optional;

public interface LicenseRepo extends CrudRepository<LicenseEntity, Integer> {

    // Abfrage zur Rückgabe freier Lizenzen basierend auf Licensing-Tabelle und Anzahl der zugewiesenen Mitarbeiter
    @Query(value = "SELECT l.id, l.amount, (l.amount - COALESCE(COUNT(lic.license_id), 0)) AS verfügbar, " +
            "l.expiration_date, l.purchase_order, l.purchase_order_originally, l.subscription_pack, l.start_date " +
            "FROM license_entity l " +
            "LEFT JOIN licensing lic ON l.id = lic.license_id " +
            "GROUP BY l.id, l.amount, l.expiration_date, l.purchase_order, l.purchase_order_originally, l.subscription_pack, l.start_date " +
            "HAVING COALESCE(COUNT(lic.license_id), 0) < l.amount", nativeQuery = true)
    public List<Object> getFreeLicenses();

    @Query(value = "SELECT l.subscription_pack, l.purchase_order, (l.amount - COALESCE(COUNT(lic.license_id), 0)) AS verfügbar " +
            "FROM license_entity l " +
            "LEFT JOIN licensing lic ON l.id = lic.license_id " +
            "GROUP BY l.id, l.amount, l.expiration_date, l.purchase_order, l.purchase_order_originally, l.subscription_pack, l.start_date " +
            "HAVING COALESCE(COUNT(lic.license_id), 0) < l.amount", nativeQuery = true)
    public List<Object> getFreeLicensesInformations();

    // Abfrage zur Rückgabe aller Lizenzen (freier und belegter Lizenzen)
    @Query(value = "SELECT l.id, l.amount, (l.amount - COALESCE(COUNT(lic.license_id), 0)) AS verfügbar, " +
            "l.expiration_date, l.purchase_order, l.purchase_order_originally, l.subscription_pack, l.start_date " +
            "FROM license_entity l " +
            "LEFT JOIN licensing lic ON l.id = lic.license_id " +
            "GROUP BY l.id, l.amount, l.expiration_date, l.purchase_order, l.purchase_order_originally, l.subscription_pack, l.start_date", nativeQuery = true)
    public List<Object> getAllLicenses();

    //Abfrage für abgelaufene Lizenzen
    @Query(value = "SELECT l.id, l.amount, (l.amount - COALESCE(COUNT(lic.license_id), 0)) AS verfügbar, " +
            "l.expiration_date, l.purchase_order, l.purchase_order_originally, l.subscription_pack, l.start_date " +
            "FROM license_entity l " +
            "LEFT JOIN licensing lic ON l.id = lic.license_id " +
            "WHERE l.expiration_date <= NOW() OR l.expiration_date <= DATE_ADD(NOW(), INTERVAL 3 MONTH) " +
            "GROUP BY l.id, l.amount, l.expiration_date, l.purchase_order, l.purchase_order_originally, l.subscription_pack, l.start_date", nativeQuery = true)
    public List<Object> getAllLicensesExpiringSoon();

    // Abfrage zur Berechnung der Lizenzstatistik (freie, belegte und Gesamtzahl)
    @Query(value = "SELECT t1.available AS frei, t2.unavailable AS belegt, t1.available + t2.unavailable AS gesamt " +
            "FROM (SELECT SUM(e1.available) as available " +
            "      FROM (SELECT (l.amount - COALESCE(COUNT(lic.license_id), 0)) AS available " +
            "            FROM license_entity l " +
            "            LEFT JOIN licensing lic ON l.id = lic.license_id " +
            "            GROUP BY l.id, l.amount, l.expiration_date, l.purchase_order, l.purchase_order_originally, l.subscription_pack " +
            "            HAVING COALESCE(COUNT(lic.license_id), 0) <= l.amount) AS e1) AS t1, " +
            "     (SELECT (COUNT(lic.license_id)) AS unavailable " +
            "      FROM licensing lic) AS t2", nativeQuery = true)
    public List<Object> getLicenseStatistic();

    @Query(value = "SELECT * FROM license_entity Where subscription_pack = :subscriptionPack AND purchase_order = :newPO AND (amount - COALESCE((SELECT COUNT(*) FROM licensing WHERE license_id = license_entity.id), 0)) = :amount", nativeQuery = true)
    public Optional<LicenseEntity> searchLicense(@Param("subscriptionPack") String subscriptionPack, @Param("newPO") String newPO, @Param("amount") int amount);
}


package com.vodafone.spring_swlzfw;

import jakarta.persistence.*;

@Entity
public class Licensing {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;

    // Viele Lizenzen können einem Mitarbeiter zugeordnet sein
    @ManyToOne
    @JoinColumn(name = "employee_id")
    private EmployeeEntity employee;

    // Viele Mitarbeiter können einer Lizenz zugeordnet sein
    @ManyToOne
    @JoinColumn(name = "license_id")
    private LicenseEntity license;

    // Getter und Setter
    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public EmployeeEntity getEmployee() {
        return employee;
    }

    public void setEmployee(EmployeeEntity employee) {
        this.employee = employee;
    }

    public LicenseEntity getLicense() {
        return license;
    }

    public void setLicense(LicenseEntity license) {
        this.license = license;
    }
}

package com.vodafone.spring_swlzfw;

import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

public interface LicensingRepo extends CrudRepository<Licensing, Integer> {

    // Abfrage aller Verknüpfungen zwischen Mitarbeitern und Lizenzen
    @Query(value = "SELECT lic.id, e.email, e.department, e.company, l.subscription_pack, l.expiration_date, l.purchase_order, l.purchase_order_originally " +
            "FROM licensing lic " +
            "JOIN employee_entity e ON lic.employee_id = e.id " +
            "JOIN license_entity l ON lic.license_id = l.id " +
            "Where l.expiration_date <= CURDATE() " +
            "OR l.expiration_date <= DATE_ADD(CURDATE(), INTERVAL 3 MONTH)", nativeQuery = true)
    public List<Object[]> getAllLicensingEntriesExpiringSoon();

    @Query(value = "SELECT lic.id, e.email, e.department, e.company, l.subscription_pack, l.expiration_date, l.purchase_order, l.purchase_order_originally " +
            "FROM licensing lic " +
            "JOIN employee_entity e ON lic.employee_id = e.id " +
            "JOIN license_entity l ON lic.license_id = l.id", nativeQuery = true)
    public List<Object[]> getAllLicensingEntries();



    // Abfrage, um alle Lizenzen für einen bestimmten Mitarbeiter zu finden
    @Query(value = "SELECT l.id, l.subscription_pack, l.expiration_date " +
            "FROM licensing lic " +
            "JOIN license_entity l ON lic.license_id = l.id " +
            "WHERE lic.employee_id = :employeeId", nativeQuery = true)
    public List<Object> findLicensesByEmployee(@Param("employeeId") int employeeId);

    // Abfrage, um alle Mitarbeiter zu finden, die eine bestimmte Lizenz verwenden
    @Query(value = "SELECT e.id, e.email, e.department " +
            "FROM licensing lic " +
            "JOIN employee_entity e ON lic.employee_id = e.id " +
            "WHERE lic.license_id = :licenseId", nativeQuery = true)
    public List<Object> findEmployeesByLicense(@Param("licenseId") int licenseId);

    @Query(value = "SELECT *" +
            "FROM licensing", nativeQuery = true)
    public List<Object> getAll();

    @Modifying
    @Transactional
    @Query(value = "UPDATE licensing SET license_id = :licenseId WHERE id = :licensingId", nativeQuery = true)
    public void updateLicense(@Param("licensingId") int licensingId, @Param("licenseId") int licenseId);
}

